#include <stddef.h>

#include "defs.h"
// Auto-generated code for recompilation of target [jhead]



typedef unsigned int size_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned int __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef int __off_t;
typedef __quad_t __off64_t;
typedef int __time_t;
typedef int __blksize_t;
typedef int __blkcnt_t;
typedef int __syscall_slong_t;
typedef struct _IO_marker _IO_marker;
typedef void _IO_lock_t;
typedef struct _IO_codecvt _IO_codecvt;
typedef struct _IO_wide_data _IO_wide_data;
typedef struct _IO_FILE{  int _flags;  char *_IO_read_ptr;  char *_IO_read_end;  char *_IO_read_base;  char *_IO_write_base;  char *_IO_write_ptr;  char *_IO_write_end;  char *_IO_buf_base;  char *_IO_buf_end;  char *_IO_save_base;  char *_IO_backup_base;  char *_IO_save_end;  _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;  int _flags2;  __off_t _old_offset;  unsigned short _cur_column;  char _vtable_offset;  char _shortbuf[1];  void *_lock;  __quad_t _offset;  _IO_codecvt *_codecvt;  _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;  size_t __pad5;  int _mode;  char _unused2[40];} _IO_FILE;
typedef _IO_FILE FILE;
typedef __time_t time_t;
typedef struct timespec{  __time_t tv_sec;  int tv_nsec;} timespec;
typedef struct tm{  int tm_sec;  int tm_min;  int tm_hour;  int tm_mday;  int tm_mon;  int tm_year;  int tm_wday;  int tm_yday;  int tm_isdst;  int tm_gmtoff;  const char *tm_zone;} tm;
enum $CFAC977D1FF097D47BD6BA025CE625B1{  _ISupper = 0x100,  _ISlower = 0x200,  _ISalpha = 0x400,  _ISdigit = 0x800,  _ISxdigit = 0x1000,  _ISspace = 0x2000,  _ISprint = 0x4000,  _ISgraph = 0x8000,  _ISblank = 0x1,  _IScntrl = 0x2,  _ISpunct = 0x4,  _ISalnum = 0x8,};
typedef enum $CFAC977D1FF097D47BD6BA025CE625B1 $CFAC977D1FF097D47BD6BA025CE625B1;
typedef struct utimbuf{  __time_t actime;  __time_t modtime;} utimbuf;
typedef unsigned char uchar;
typedef struct Section_t{  unsigned char *Data;  int Type;  unsigned int Size;} Section_t;
typedef struct $8A0CC94EF846C94D27E9CAA990C4DE71{  char Present;  char ResolutionUnits;  short XDensity;  short YDensity;} $8A0CC94EF846C94D27E9CAA990C4DE71;
typedef struct ImageInfo_t{  char FileName[4097];  __time_t FileDateTime;  struct $8A0CC94EF846C94D27E9CAA990C4DE71 JfifHeader;  unsigned int FileSize;  char CameraMake[32];  char CameraModel[40];  char DateTime[20];  unsigned int Height;  unsigned int Width;  int Orientation;  int IsColor;  int Process;  int FlashUsed;  float FocalLength;  float ExposureTime;  float ApertureFNumber;  float Distance;  float CCDWidth;  float ExposureBias;  float DigitalZoomRatio;  int FocalLength35mmEquiv;  int Whitebalance;  int MeteringMode;  int ExposureProgram;  int ExposureMode;  int ISOequivalent;  int LightSource;  int DistanceRange;  float xResolution;  float yResolution;  int ResolutionUnit;  char Comments[16000];  int ThumbnailOffset;  int ThumbnailSize;  int LargestExifOffset;  char ThumbnailAtEnd;  int ThumbnailSizeOffset;  int DateTimeOffsets[10];  int numDateTimeTags;  int GpsInfoPresent;  char GpsLat[31];  char GpsLong[31];  char GpsAlt[20];  int QualityGuess;} ImageInfo_t;
enum ReadMode_t{  READ_METADATA = 0x1,  READ_IMAGE = 0x2,  READ_ALL = 0x3,  READ_ANY = 0x5,};
typedef enum ReadMode_t ReadMode_t;
typedef struct stat{  __u_quad_t st_dev;  unsigned short __pad1;  __ino_t st_ino;  __mode_t st_mode;  unsigned int st_nlink;  __uid_t st_uid;  __gid_t st_gid;  __u_quad_t st_rdev;  unsigned short __pad2;  __off_t st_size;  __blksize_t st_blksize;  __blkcnt_t st_blocks;  struct timespec st_atim;  struct timespec st_mtim;  struct timespec st_ctim;  unsigned int __glibc_reserved4;  unsigned int __glibc_reserved5;} stat;
typedef struct TagTable_t{  unsigned short Tag;  char *Desc;} TagTable_t;

void __prd_init() {
}
void __prd_exit() {
}


/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/



//--------------------------------------------------------------------
// Function Declarations


typedef void (*pErrNonfatal)(const char *, int, int);
pErrNonfatal ErrNonfatal = NULL;

typedef int (*pGet16u)(void *);
pGet16u Get16u = NULL;

typedef unsigned int (*pGet32u)(void *);
pGet32u Get32u = NULL;

typedef void (*pPrintFormatNumber)(void *, int, int);
pPrintFormatNumber PrintFormatNumber = NULL;


// char *strstr(const char *haystack, const char *needle);
typedef  char * (*pstrstr)(const char *haystack, const char *needle);
pstrstr strstr=NULL;

// int puts(const char *s);
typedef int (*pputs)(const char *s);
pputs puts=NULL;

// int putchar(int c);
typedef int (*pputchar)(int c);
pputchar putchar=NULL;

// int __cdecl __printf_chk(_DWORD, _DWORD, _DWORD); weak
typedef int  (*p__printf_chk)(_DWORD, _DWORD, _DWORD); 
p__printf_chk __printf_chk=NULL;

// int putc(int c, FILE *stream);
typedef int (*pputc)(int c, FILE *stream);
pputc putc=NULL;



//--------------------------------------------------------------------
// Decompiled Variables

//--------------------------------------------------------------------
// Data declarations

int BytesPerFormat[13] = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 }; // idb
int *(pDumpExifMap);
#define DumpExifMap (*pDumpExifMap)
 // idb
int *(pShowTags);
#define ShowTags (*pShowTags)
 // idb
int *(pMotorolaOrder);
#define MotorolaOrder (*pMotorolaOrder)
 // idb
int MotorolaOrderSave_4251; // idb
ImageInfo_t *(pImageInfo);
#define ImageInfo (*pImageInfo)
 // idb
// extern struct _IO_FILE *stdout;
struct _IO_FILE **(pstdout);
#define stdout (*pstdout)




//--------------------------------------------------------------------
// Decompiled Function Declarations
void  ProcessMakerNote(unsigned char *ValuePtr, int ByteCount, unsigned char *OffsetBase, unsigned int ExifLength);




//--------------------------------------------------------------------
// Decompiled Function Definitions
//----- (0000B4D0) --------------------------------------------------------
void  ProcessMakerNote(unsigned char *ValuePtr, int ByteCount, unsigned char *OffsetBase, unsigned int ExifLength)
{
  int v4; // eax
  int v5; // ebp
  unsigned char *Short; // ebp
  int v7; // eax
  int v8; // edi
  int v9; // eax
  int v10; // esi
  int v11; // eax
  unsigned int v12; // eax
  unsigned char *v13; // ebp
  unsigned char *v14; // ecx
  unsigned char *v15; // edi
  unsigned char *v16; // esi
  int v17; // eax
  int v18; // [esp+8h] [ebp-54h]
  int a2; // [esp+18h] [ebp-44h]
  unsigned char *Long; // [esp+1Ch] [ebp-40h]
  int v21; // [esp+20h] [ebp-3Ch]
  int v22; // [esp+20h] [ebp-3Ch]
  unsigned char *v23; // [esp+2Ch] [ebp-30h]
  int v24; // [esp+3Ch] [ebp-20h]

  if ( strstr(ImageInfo.CameraMake, "Canon") )
  {
    v4 = MotorolaOrder;
    MotorolaOrder = 0;
    MotorolaOrderSave_4251 = v4;
    v5 = Get16u(ValuePtr);
    if ( &ValuePtr[12 * v5 + 2] > &OffsetBase[ExifLength] )
    {
      ErrNonfatal("Illegally sized Exif makernote subdir (%d entries)", v5, 0);
    }
    else
    {
      if ( DumpExifMap )
        __printf_chk(1, "Map: %05u-%05u: Directory (makernote)\n", ValuePtr - OffsetBase);
      if ( ShowTags )
        __printf_chk(1, "(dir has %d entries)\n", v5);
      v23 = &ValuePtr[12 * v5 + 2];
      if ( v5 > 0 )
      {
        for ( Short = ValuePtr + 2; Short != v23; Short += 12 )
        {
          while ( 1 )
          {
            a2 = Get16u(Short);
            v8 = Get16u(Short + 2);
            v9 = Get32u(Short + 4);
            v10 = v9;
            if ( v9 <= 0x10000 )
              break;
            Short += 12;
            ErrNonfatal("Bad components count %x", v9, 0);
            if ( Short == v23 )
              goto LABEL_20;
          }
          if ( v8 > 12 )
          {
            ErrNonfatal("Illegal Exif number format %d for maker tag %04x", v8, a2);
          }
          else if ( (unsigned int)v9 > 0x10000 )
          {
            ErrNonfatal("Too many components (%d) for Exif maker tag %04x", v9, a2);
          }
          else
          {
            v21 = v9 * BytesPerFormat[v8];
            Long = Short + 8;
            if ( v21 <= 4 )
              goto LABEL_12;
            v12 = Get32u(Long);
            if ( v12 <= 0x10000 && (unsigned)ExifLength >= v12 + v21 )
            {
              Long = &OffsetBase[v12];
              if ( DumpExifMap )
              {
                __printf_chk(1, "Map: %05d-%05d:   Data for makernote tag %04x\n", v12);
                if ( ShowTags )
                {
LABEL_33:
                  __printf_chk(1, "            Canon maker tag %04x Value = ", a2);
                  if ( v8 == 2 || v8 == 7 )
                  {
                    if ( ShowTags )
                    {
                      putchar(34);
                      v14 = &Long[v21];
                      if ( v21 > 0 )
                      {
                        v22 = v8;
                        v15 = Long;
                        v24 = v10;
                        v16 = v14;
                        do
                        {
                          while ( 1 )
                          {
                            v17 = *v15;
                            if ( (unsigned char)v17 > 0x1Fu )
                              break;
                            if ( v16 == ++v15 )
                              goto LABEL_54;
                          }
                          ++v15;
                          putchar(v17);
                        }
                        while ( v16 != v15 );
LABEL_54:
                        v8 = v22;
                        v10 = v24;
                      }
                      puts("\"");
                    }
                  }
                  else if ( ShowTags )
                  {
                    PrintFormatNumber(Long, v8, v21);
                    putchar(10);
                  }
                }
              }
              else
              {
LABEL_12:
                if ( ShowTags )
                  goto LABEL_33;
              }
              if ( a2 == 1 && v10 > 16 )
              {
				if (v21 < 17*sizeof(short)) continue;
                v7 = Get16u(Long + 32);
                if ( (unsigned int)(v7 - 16) <= 8 )
                  ImageInfo.ISOequivalent = 50 << (v7 - 16);
              }
              else if ( a2 == 4 && v8 == 3 )
              {
				if (v21 < 20*sizeof(short)) continue;
                if ( v10 > 7 )
                {
                  switch ( Get16u(Long + 14) )
                  {
                    case 1:
                    case 2:
                      ImageInfo.LightSource = 1;
                      break;
                    case 3:
                      ImageInfo.LightSource = 3;
                      break;
                    case 4:
                      ImageInfo.LightSource = 2;
                      break;
                    case 5:
                      ImageInfo.LightSource = 4;
                      break;
                    default:
                      break;
                  }
                }
                if ( v10 > 19 && ImageInfo.Distance <= 0.0 )
                {
                  v11 = Get16u(Long + 38);
                  if ( v11 == 0xFFFF )
                    ImageInfo.Distance = -1.0;
                  else
                    ImageInfo.Distance = (long double)v11 / 100.0;
                }
              }
              continue;
            }
            ErrNonfatal("Illegal value pointer for Exif maker tag %04x", a2, 0);
          }
        }
      }
    }
LABEL_20:
    MotorolaOrder = MotorolaOrderSave_4251;
  }
  else if ( ShowTags )
  {
    if ( ByteCount > 0 )
    {
      v13 = ValuePtr;
      while ( 1 )
      {
        __printf_chk(1, " %02x", *v13);
        if ( v13 == &ValuePtr[ByteCount - 1] )
          break;
        if ( ++v13 == ValuePtr + 11 )
        {
          __printf_chk(1, "...", v18);
          break;
        }
      }
    }
    __printf_chk(1, " (%d bytes)", ByteCount);
    putchar(10);
  }
}
// B86C: variable 'v18' is possibly undefined
// 2320: using guessed type int  __printf_chk(int, int, int);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0



void  det_ProcessMakerNote(
	void* myGet16u,
	void* myGet32u,
	void* myErrNonfatal,
	void* myPrintFormatNumber,
	void* myImageInfo,
	void* myDumpExifMap,
	void* myMotorolaOrder,
	void* myShowTags,
    void** mystdout,
    void** mystrstr,
    void** myputs,
    void** myputchar,
    void** my__printf_chk,
    void** myputc,
	unsigned char * ValuePtr,
	int ByteCount,
	unsigned char * OffsetBase,
	unsigned int ExifLength
)
{
	pImageInfo = (ImageInfo_t*) myImageInfo;
	pDumpExifMap = (int*) myDumpExifMap;
	pMotorolaOrder = (int*) myMotorolaOrder;
	pShowTags = (int*) myShowTags;
	pstdout = (struct _IO_FILE**) mystdout;
	strstr = (pstrstr) *mystrstr;
	puts = (pputs) *myputs;
	putchar = (pputchar) *myputchar;
	__printf_chk = (p__printf_chk) *my__printf_chk;
	putc = (pputc) *myputc;
	Get16u = (pGet16u) (myGet16u);
	Get32u = (pGet32u) (myGet32u);
	ErrNonfatal = (pErrNonfatal) (myErrNonfatal);
	PrintFormatNumber = (pPrintFormatNumber) (myPrintFormatNumber);

	__prd_init();
	ProcessMakerNote(
		ValuePtr,
		ByteCount,
		OffsetBase,
		ExifLength
	);

	__prd_exit();

	 	asm(
"nop\n\t"
"mov    -0x4(%ebp),%ebx\n\t"
"nop\n\t"
"add    $0x4,%esp\n\t"
"nop\n\t"
"pop %ebx\n\t"
"pop %ebp\n\t"
"pop %ecx\n\t"
"add $0x38,%esp\n\t"
"push %ecx\n\t"
"ret\n\t"
);

	return;
}



void main()
{
	det_ProcessMakerNote(
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		(unsigned char *) NULL,
		(int) 0,
		(unsigned char *) NULL,
		(unsigned int) 0
	);
}
